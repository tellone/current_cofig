, that song again. It keeps sneaking up on me. One of those you just start humming without knowing the words. Even in my worn out and uneasy state,v
, I could not get the tune out of my head. If only I wasn't headed for a job interview and to make things worse I'm a nervous hummer. I hadn't slept well last night,v
h,v
  pending # express the regexp above with the code you wish you had,V
,V
  @movie.update_attribute(:showtime_date, Date.parse(date)),V
  pending # express thedregexp above with the code you wish you had,V
ddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd,V
You can implement step definitions for undefined steps with these snippets:,V
Using the wip profile...#Creation Date: 2012-04-10Feature: showtime descriptions  So that a I can fit movies the tv to my  scheduel. A moive fan want accurate time tables  @wip  Scenario: show minutes for time withour seconds                       # features/showtime_descriptions.feature:9    Given a movie listing                                               # features/showtime_descriptions.feature:10    When I set the show time to "2007-10-10" at "2:15pm"                # features/showtime_descriptions.feature:11    Then the showtime describtion shoud say "October 10 2007 at 2:15pm" # features/showtime_descriptions.feature:121 scenario (1 undefined)3 steps (3 undefined)0m0.354s,v
    When I ,V
    When I set the show time to "2007-10-10" at "2:15 pm",V
   #Scenario Outline:    #Gvien "<code>"    #when "<other code>"    #then "more code"  ,v
   ,V
    And,V
    #############################################,V
#Feature Name: showtime_descriptions.feature,V
#Creator: Filip Pettersson,V
 ,v
,v
group :test do,V
gem "cucumber-rails",V
  gem "cucumber-rails",V
		let twitvim_token_file = "/etc/.twitvim.token",V
let g:fuf_dataDir = '~/.vim/misc/vim-fuf-data'let g:fuf_mrufile_exclude = '\v\~$|\.(o|exe|dll|bak|aux|zip|rar|orig|sw[po])$|^(\/\/|\\\\|\/mnt\/|\/media\/)',V
  autocmd FileType ruby setlocal tw=79 isfname+=: comments=:#\,V
let pymode_lint_checker = "pep8",V
"PyMode,V
  au FileType python setlocal ai et sta tw=79 sw=4 sts=4,V
  au FileType python setlocal linebreak nolist,V
 setlocal ai et sta sw=2 sts=2,v
  au FileType python syn keyword pythonDecorator self,V
"{{{2 " => Python sectionaugroup PYset  au!  au FileType python syn keyword pythonDecorator self  au FileType python setlocal linebreak nolist  au FileType python setlocal ai et sta tw=79 sw=4 sts=4augroup END"PyModelet pymode_lint_checker = "pep8",V
"rails,V
"PyModelet pymode_lint_checker = "pep8",v
  au BufWrite *.py :call DeleteTrailingWS(),V
let g:rails_menu=1,V
  end,V
# Bundle gems for the local environment. Make sure to,V
# put test-only gems in this group so their generators,V
# and rake tasks are available in development mode:,V
 end,V
# group :development, :test do#   gem 'webrat'#,v
  gem "rspec-rails",">=2.0.0",V
# End of lines added by compinstallcompdef 'local expl; _description files expl "picture file"; _files "$expl[@]" -g "*.(#i)(png|gif|jpeg|jpg|tiff|tif|pbm|pgm|ppm|xbm|xpm|ras(|t)|tga|rle|rgb|bmp|pcx|fits|pm)(-.)"' feh,v
zstyle ':completion:*' users tpope root $USER ${watch/notme/},V
# End of lines added by compinstallcompdef 'local expl; _description files expl "picture file"; _files "$expl[@]" -g "*.(#i)(png|gif|jpeg|jpg|tiff|tif|pbm|pgm|ppm|xbm|xpm|ras(|t)|tga|rle|rgb|bmp|pcx|fits|pm)(-.)"' feh,V
    @secret.include?(@guess[index]) && !exact_match?(index),V
  def numbers_match?(index),V
    count,V
    end,V
        secret.delete_at(secret.index(number)),V
      count + (exact_match?(index) ? 1 : 0),V
    (0..3).inject(0) do |count, index|      count + (numbers_match?(index) ?  1 : 0) ,v
  def nr_matches    (0..3).inject(0) do |count, index|      count + (numbers_match?(index) ?  1 : 0)    end  end ,v
+++++---+ - ,2
    Scenarios: All matches      | code | guess | mark |      | 1234 | 1234  | ++++ |      | 1234 | 1243  | ++-- |      | 1234 | 3124  | +--- |      | 1234 | 2341  | ---- |,V
   Scenarios: All matches,v
game.start,V
scribe "#exact_matches" do      context "with no matches" do        it "it returns 0" do          marker = Marker.new('1234','5555')          marker.exact_matches.should == 0        end      end      context "with one match on wrong place" do        it "returns 0" do          marker = Marker.new('1234','3555')          marker.exact_matches.should == 0       end      end     context "with 1 exact match" do       it "returns 1" do          marker = Marker.new('1234','5535')          marker.exact_matches.should == 1      end     end     context "with one number match and one exact match (in that order)" do       it "returns 1" do          marker = Marker.new('1234','5135')          marker.exact_matches.should == 1       end     end    end,v
     context "with 1 exact and one nr match" do       it "returns 1" do         game.start('1234')         output.should_receive(:puts).with('--')         game.guess('2355')       end     end,V
atch" do       it "returns 1" do         game.start('1234')         output.should_receive(:puts).with('--')         game.guess('2355')       end     end,v
          marker = Marker.new('1234','5535')          marker.exact_matches.should == 1,V
          marker = Marker.new('1234','3555')          marker.exact_matches.should == 0,V
          marker = Marker.new('1234','5555')          marker.exact_matches.should == 0,V
          output.should_receive(:puts).with(''),V
          game.guess('5555'),V
    let(:output) { double('output').as_null_object }     let(:game) { Game.new(output) }          describe "#start" do    # before(:each) do    # output = double('output').as_null_object    # game = Game.new(output)    #  end      it "sends a welcome message" do        output.should_receive(:puts).with('Welcome to Codebreaker')        game.start('1234')      end      it "prompts for the first guess" do        output.should_receive(:puts).with('Enter guess: ')        game.start('1234')      end    end,V
r,v
require 'spec_helper'module Codebreaker  describe Game do    let(:output) { double('output').as_null_object }     let(:game) { Game.new(output) }          describe "#start" do    # before(:each) do    # output = double('output').as_null_object    # game = Game.new(output)    #  end      it "sends a welcome message" do        output.should_receive(:puts).with('Welcome to Codebreaker')        game.start('1234')      end      it "prompts for the first guess" do        output.should_receive(:puts).with('Enter guess: ')        game.start('1234')      end    end    describe "#guess" do      context "with no matches" do        it "sends a mark with ''" do          game.start('1234')          output.should_receive(:puts).with('')          game.guess('5555')        end      end      context "with one match on wrong place" do        it "sends a mark with '-'" do          game.start('1234')          output.should_receive(:puts).with('-')          game.guess('3555')        end      end     context "with 1 exact match" do       it "sends a mark with '+'" do         game.start('1234')         output.should_receive(:puts).with('+')         game.guess('1555')       end     end     context "with 2 number matches" do       it "sends a mark with '--'" do         game.start('1234')         output.should_receive(:puts).with('--')         game.guess('2355')       end     end     context "with 1 number match and 1 exact match (in that order)" do       it "sends a mark with '+-'" do         game.start('1234')         output.should_receive(:puts).with('+-')         game.guess('2535')       end     end    end  endend,v
class Marker  def initialize(secret, guess)    @secret, @guess = secret, guess  end  def nr_matches    (0..3).inject(0) do |count, index|      count + (numbers_match?(index) ?  1 : 0)    end  end  def exact_matches    (0..3).inject(0) do |count, index|    count + (exact_match?(index) ? 1 : 0)    end  end  def exact_match?(index)    @guess[index] == @secret[index]  end  def numbers_match?(index)    @secret.include?(@guess[index]) && !exact_match?(index)  endend,v
  def nr_matches(guess)    (0..3).inject(0) do |count, index|      count + (numbers_match?(guess, index) ?  1 : 0)    end  end  def exact_matches(guess)    (0..3).inject(0) do |count, index|    count + (exact_match?(guess, index) ? 1 : 0)    end  end  def exact_match?(guess, index)    guess[index] == @secret[index]  end  def numbers_match?(guess, index)    @secret.include?(guess[index]) && !exact_match?(guess, index)  end,V
class Marker  def initialize(secret)    @secret=secret  end  def nr_matches(guess)    (0..3).inject(0) do |count, index|      count + (numbers_match?(guess, index) ?  1 : 0)    end  end  def exact_matches(guess)    (0..3).inject(0) do |count, index|    count + (exact_match?(guess, index) ? 1 : 0)    end  end  def exact_match?(guess, index)    guess[index] == @secret[index]  end  def numbers_match?(guess, index)    @secret.include?(guess[index]) && !exact_match?(guess, index)  endend,V
d,v
f nr_matches(guess)    (0..3).inject(0) do |count, index|      count + (numbers_match?(guess, index) ?  1 : 0)    end  end  def exact_matches(guess)    (0..3).inject(0) do |count, index|    count + (exact_match?(guess, index) ? 1 : 0)    end  end  def exact_match?(guess, index)    guess[index] == @secret[index]  end  def numbers_match?(guess, index)    @secret.include?(guess[index]) && !exact_match?(guess, index)  end,v
      count + (numbers_match?(guess, index) ?  0 : 1),V
  def exact_match?(guess, index),V
    exact_matches,V
    exact_matches = 0,V
    nr_matches,V
      end,V
        nr_matches += 1,V
    nr_matches = 0,V
    def nr_matches(guess)    nr_matches = 0    (0..3).each do |index|      if numbers_match?(guess, index)        nr_matches += 1      end    end,V
require 'codebreaker/marker',V
end,V
Report erratum,V
    describe "#guess" do      context "with no matches" do        it "sends a mark with ''" do          game.start('1234')          output.should_receive(:puts).with('')          game.guess('5555')        end      end      context "with one match on wrong place" do        it "sends a mark with '-'" do          game.start('1234')          output.should_receive(:puts).with('-')          game.guess('3555')        end      end     context "with 1 exact match" do       it "sends a mark with '+'" do         game.start('1234')         output.should_receive(:puts).with('+')         game.guess('1555')       end     end     context "with 2 number matches" do       it "sends a mark with '--'" do         game.start('1234')         output.should_receive(:puts).with('--')         game.guess('2355')       end     end     context "with 1 number match and 1 exact match (in that order)" do       it "sends a mark with '+-'" do         game.start('1234')         output.should_receive(:puts).with('+-')         game.guess('2535')       end     end,V
require 'codebreaker/game',V
(,v
  let g:fuf_modesDisable = [],V
  let g:fuf_mrufile_maxItem = 400  let g:fuf_mrucmd_maxItem = 400,V
"MRU,V
map <leader>f :MRU<CR>,V
let MRU_Max_Entries = 400,V
let MRU_File = '/home/tellone/.vim/misc/.vim_mru_files',V
let g:fuf_mrufile_exclude = '\v\~$|\.(o|exe|dll|bak|orig|sw[po])$|^(\/\/|\\\\|\/mnt\/|\/media\/)',v
  let g:fuf_keyOpen = '<CR>',V
let g:fuf_dataDir = '~/.vim-fuf-data',v
    number_match_count,V
